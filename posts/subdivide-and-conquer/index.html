<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Subdivide and Conquer | joekbullard</title><meta name=keywords content><meta name=description content="Dealing with large and complex geometries in postgis can be computationally expensive, even with a spatial index. To understand why this is we need to have some understanding of how a spatial index works. In simple terms, a spatial index is a bounding box that encapsulates the extent of a geometry, using a spatial index can rapidly speed up spatial processing by first checking which bounding boxes intersect - a comparatively quick process - as opposed to which raw geometries intersect - potentially a lot slower - and more so as the size of your dataset increases."><meta name=author content="Me"><link rel=canonical href=https://joekbullard.github.io/posts/subdivide-and-conquer/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.89903f5336eff9763209fb4cd1e860a14715773bf5fd93b39c714e2690162751.css integrity="sha256-iZA/Uzbv+XYyCftM0ehgoUcVdzv1/ZOznHFOJpAWJ1E=" rel="preload stylesheet" as=style><link rel=icon href=https://joekbullard.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://joekbullard.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://joekbullard.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://joekbullard.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://joekbullard.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Subdivide and Conquer"><meta property="og:description" content="Dealing with large and complex geometries in postgis can be computationally expensive, even with a spatial index. To understand why this is we need to have some understanding of how a spatial index works. In simple terms, a spatial index is a bounding box that encapsulates the extent of a geometry, using a spatial index can rapidly speed up spatial processing by first checking which bounding boxes intersect - a comparatively quick process - as opposed to which raw geometries intersect - potentially a lot slower - and more so as the size of your dataset increases."><meta property="og:type" content="article"><meta property="og:url" content="https://joekbullard.github.io/posts/subdivide-and-conquer/"><meta property="og:image" content="https://joekbullard.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-21T01:12:57+00:00"><meta property="article:modified_time" content="2022-11-21T01:12:57+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://joekbullard.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Subdivide and Conquer"><meta name=twitter:description content="Dealing with large and complex geometries in postgis can be computationally expensive, even with a spatial index. To understand why this is we need to have some understanding of how a spatial index works. In simple terms, a spatial index is a bounding box that encapsulates the extent of a geometry, using a spatial index can rapidly speed up spatial processing by first checking which bounding boxes intersect - a comparatively quick process - as opposed to which raw geometries intersect - potentially a lot slower - and more so as the size of your dataset increases."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://joekbullard.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Subdivide and Conquer","item":"https://joekbullard.github.io/posts/subdivide-and-conquer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Subdivide and Conquer","name":"Subdivide and Conquer","description":"Dealing with large and complex geometries in postgis can be computationally expensive, even with a spatial index. To understand why this is we need to have some understanding of how a spatial index works. In simple terms, a spatial index is a bounding box that encapsulates the extent of a geometry, using a spatial index can rapidly speed up spatial processing by first checking which bounding boxes intersect - a comparatively quick process - as opposed to which raw geometries intersect - potentially a lot slower - and more so as the size of your dataset increases.","keywords":[],"articleBody":"Dealing with large and complex geometries in postgis can be computationally expensive, even with a spatial index. To understand why this is we need to have some understanding of how a spatial index works. In simple terms, a spatial index is a bounding box that encapsulates the extent of a geometry, using a spatial index can rapidly speed up spatial processing by first checking which bounding boxes intersect - a comparatively quick process - as opposed to which raw geometries intersect - potentially a lot slower - and more so as the size of your dataset increases. If you want to learn a little then the postgis documentation does a good job of explaining it further.\nSo with this in mind, let’s get back to the large and complex geometries. When you’re looking to identify spatial relationships between geometries that cover geographically large areas comprising a vast number of vertices - think a polygon of a large country such as Russia or USA - you end up with vast bounding boxes. An example I’ve been grappling with recently involved intersecting large local authorities in Scotland with 100s of 1000s of rows of land cover and soil classifcation types. In these cases, even with a spatial index improving efficiency, you’re still looking at undertaking a vast number of spatial operations - taking a long time to complete.\nBut what if there was a way around this? Knowing that large complex geometries = slow, we can assume that the opposite is true of small and simple geometries. It is possible to apply this logic by using the ST_Subdivide function. In effect, this function breaks a polygon down into smaller parts, as these smaller parts cover a smaller geographic extent, the bounding box covers a much smaller area and will therefore intersect with far fewer geometries - speeding up processing time.\nLet’s take an example using the district borough unitary layer included with the OS Boundary-Line dataset.\nSELECT geom FROM district_borough_unitary WHERE name ILIKE 'highland' Now let’s try adding a bounding box to that geometry to see how far it extends.\nSELECT ST_Envelope(geom) FROM district_borough_unitary WHERE name ILIKE 'highland' As you can see, the bounding box that forms the index covers a vast area beyond the extent of the original geometry, this means that when spatial queries are running against this geometry, all those areas will be included, dramtatically increasing processing time.\nLet’s do the same but using ST_Subdivide on the geometry.\nSELECT ST_Subdivide(geom) FROM district_borough_unitary WHERE name ILIKE 'highland' As you can see, the original geometry has been broken down into a large number of smaller polygons, each of which has a much smaller bounding box. So what impact does this have on query performance? Let’s investigate with a spatial query against the HABMOS dataset to find out how many forest polygons intersect our study area.\nFirst, let’s try with the plain geometry:\nSELECT COUNT(*) FROM public.district_borough_unitary, public.habmos WHERE ST_Intersects(geom, wkb_geometry) AND habitat ILIKE '%forest%' So I went and made a cup of tea, came back and aborted the query as it was taking so long (this was carried out on postgres running on docker environment on my raspberry pi, so not the beefiest of hardware, but still)\nAnd using the the subdivded geometry….\nSELECT COUNT(*) FROM public.subdivded_geom, public.habmos WHERE ST_Intersects(geom, habmos.wkb_geometry) AND habitat ILIKE '%forest%' This completed in just over 7 seconds, or 7 seconds and 251ms to be precise. So a real stark difference between the two, demonstrating clearly why it can be of great benefit to ST_Subdivide to conquer those larger polygons!\n","wordCount":"593","inLanguage":"en","datePublished":"2022-11-21T01:12:57Z","dateModified":"2022-11-21T01:12:57Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://joekbullard.github.io/posts/subdivide-and-conquer/"},"publisher":{"@type":"Organization","name":"joekbullard","logo":{"@type":"ImageObject","url":"https://joekbullard.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://joekbullard.github.io accesskey=h title="Home (Alt + H)"><img src=https://joekbullard.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://joekbullard.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://joekbullard.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://joekbullard.xyz title=joekbullard.xyz><span>joekbullard.xyz</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://joekbullard.github.io>Home</a>&nbsp;»&nbsp;<a href=https://joekbullard.github.io/posts/>Posts</a></div><h1 class=post-title>Subdivide and Conquer<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup></h1><div class=post-meta><span title='2022-11-21 01:12:57 +0000 UTC'>November 21, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/subdivide-and-conquer.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Dealing with large and complex geometries in postgis can be computationally expensive, even with a spatial index. To understand why this is we need to have some understanding of how a spatial index works. In simple terms, a spatial index is a bounding box that encapsulates the extent of a geometry, using a spatial index can rapidly speed up spatial processing by first checking which bounding boxes intersect - a comparatively quick process - as opposed to which raw geometries intersect - potentially a lot slower - and more so as the size of your dataset increases. If you want to learn a little then the <a href=https://postgis.net/workshops/postgis-intro/indexing.html>postgis documentation</a> does a good job of explaining it further.</p><p>So with this in mind, let&rsquo;s get back to the large and complex geometries. When you&rsquo;re looking to identify spatial relationships between geometries that cover geographically large areas comprising a vast number of vertices - think a polygon of a large country such as Russia or USA - you end up with vast bounding boxes. An example I&rsquo;ve been grappling with recently involved intersecting large local authorities in Scotland with 100s of 1000s of rows of land cover and soil classifcation types. In these cases, even with a spatial index improving efficiency, you&rsquo;re still looking at undertaking a vast number of spatial operations - taking a long time to complete.</p><p>But what if there was a way around this? Knowing that large complex geometries = slow, we can assume that the opposite is true of small and simple geometries. It is possible to apply this logic by using the <code>ST_Subdivide</code> function. In effect, this function breaks a polygon down into smaller parts, as these smaller parts cover a smaller geographic extent, the bounding box covers a much smaller area and will therefore intersect with far fewer geometries - speeding up processing time.</p><p>Let&rsquo;s take an example using the district borough unitary layer included with the <a href=https://www.ordnancesurvey.co.uk/business-government/products/boundaryline>OS Boundary-Line</a> dataset.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-postgresql data-lang=postgresql><span class=line><span class=cl><span class=k>SELECT</span> <span class=n>geom</span>
</span></span><span class=line><span class=cl><span class=k>FROM</span> <span class=n>district_borough_unitary</span>
</span></span><span class=line><span class=cl><span class=k>WHERE</span> <span class=k>name</span> <span class=k>ILIKE</span> <span class=s1>&#39;highland&#39;</span>
</span></span></code></pre></div><p><img loading=lazy src=/highland.jpg alt="Highland standard"></p><p>Now let&rsquo;s try adding a bounding box to that geometry to see how far it extends.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-postgresql data-lang=postgresql><span class=line><span class=cl><span class=k>SELECT</span> <span class=n>ST_Envelope</span><span class=p>(</span><span class=n>geom</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>FROM</span> <span class=n>district_borough_unitary</span>
</span></span><span class=line><span class=cl><span class=k>WHERE</span> <span class=k>name</span> <span class=k>ILIKE</span> <span class=s1>&#39;highland&#39;</span>
</span></span></code></pre></div><p><img loading=lazy src=/highlandbbox.jpg alt="Highland bounding box"></p><p>As you can see, the bounding box that forms the index covers a vast area beyond the extent of the original geometry, this means that when spatial queries are running against this geometry, all those areas will be included, dramtatically increasing processing time.</p><p>Let&rsquo;s do the same but using <code>ST_Subdivide</code> on the geometry.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-postgresql data-lang=postgresql><span class=line><span class=cl><span class=k>SELECT</span> <span class=n>ST_Subdivide</span><span class=p>(</span><span class=n>geom</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>FROM</span> <span class=n>district_borough_unitary</span>
</span></span><span class=line><span class=cl><span class=k>WHERE</span> <span class=k>name</span> <span class=k>ILIKE</span> <span class=s1>&#39;highland&#39;</span>
</span></span></code></pre></div><p><img loading=lazy src=/highland_subdivide.jpg alt="Highland subdivide"></p><p>As you can see, the original geometry has been broken down into a large number of smaller polygons, each of which has a much smaller bounding box. So what impact does this have on query performance? Let&rsquo;s investigate with a spatial query against the <a href="https://gateway.snh.gov.uk/natural-spaces/dataset.jsp?dsid=HABMOS">HABMOS dataset</a> to find out how many forest polygons intersect our study area.</p><p>First, let&rsquo;s try with the plain geometry:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-postgresql data-lang=postgresql><span class=line><span class=cl><span class=k>SELECT</span> <span class=n>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>FROM</span> 
</span></span><span class=line><span class=cl>	<span class=n>public</span><span class=mf>.</span><span class=n>district_borough_unitary</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>public</span><span class=mf>.</span><span class=n>habmos</span>
</span></span><span class=line><span class=cl><span class=k>WHERE</span> 
</span></span><span class=line><span class=cl>	<span class=n>ST_Intersects</span><span class=p>(</span><span class=n>geom</span><span class=p>,</span> <span class=n>wkb_geometry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>AND</span> <span class=n>habitat</span> <span class=k>ILIKE</span> <span class=s1>&#39;%forest%&#39;</span>
</span></span></code></pre></div><p>So I went and made a cup of tea, came back and aborted the query as it was taking so long (this was carried out on postgres running on docker environment on my raspberry pi, so not the beefiest of hardware, but still)</p><p>And using the the subdivded geometry&mldr;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-postgresql data-lang=postgresql><span class=line><span class=cl><span class=k>SELECT</span> <span class=n>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>FROM</span>  
</span></span><span class=line><span class=cl>	<span class=n>public</span><span class=mf>.</span><span class=n>subdivded_geom</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=n>public</span><span class=mf>.</span><span class=n>habmos</span>
</span></span><span class=line><span class=cl><span class=k>WHERE</span> 
</span></span><span class=line><span class=cl>	<span class=n>ST_Intersects</span><span class=p>(</span><span class=n>geom</span><span class=p>,</span> <span class=n>habmos</span><span class=mf>.</span><span class=n>wkb_geometry</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>AND</span> <span class=n>habitat</span> <span class=k>ILIKE</span> <span class=s1>&#39;%forest%&#39;</span>
</span></span></code></pre></div><p>This completed in just over 7 seconds, or 7 seconds and 251ms to be precise. So a real stark difference between the two, demonstrating clearly why it can be of great benefit to <code>ST_Subdivide</code> to conquer those larger polygons!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://joekbullard.github.io/posts/docker-geoserver-part-1/><span class=title>« Prev</span><br><span>Docker Geoserver Part 1</span></a>
<a class=next href=https://joekbullard.github.io/posts/geopandas-nbn/><span class=title>Next »</span><br><span>Manipulating NBN species data with Geopandas</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Subdivide and Conquer on twitter" href="https://twitter.com/intent/tweet/?text=Subdivide%20and%20Conquer&url=https%3a%2f%2fjoekbullard.github.io%2fposts%2fsubdivide-and-conquer%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Subdivide and Conquer on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjoekbullard.github.io%2fposts%2fsubdivide-and-conquer%2f&title=Subdivide%20and%20Conquer&summary=Subdivide%20and%20Conquer&source=https%3a%2f%2fjoekbullard.github.io%2fposts%2fsubdivide-and-conquer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Subdivide and Conquer on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjoekbullard.github.io%2fposts%2fsubdivide-and-conquer%2f&title=Subdivide%20and%20Conquer"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://joekbullard.github.io>joekbullard</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>